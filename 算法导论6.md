主要内容是：算法导论14章数据结构的扩张的内容

###数据结构扩张
数据结构的扩张就是对基本的数据结构进行扩展，满足一些其他的需求。

扩展一种数据结构的方法是：
1. 选择一种基础的数据结构
2. 确定基础数据结构中要维护的附加信息
3. 检验基础数据结构上的基本修改操作能否维护附加信息
4. 设计一个新的操作


这里举出两个典型的例子：顺序统计树(order-statistic tree)，区间树(interval tree)，这两个例子都是对红黑树的扩展。


####顺序统计树
顺序统计树的功能是在一个n个元素的集合中，在$O(lgn)$的时间求出一个元素的顺序统计量(第i个顺序统计量是该集合中第i小的元素)。而对这颗顺序统计树的维护时间(包括插入和删除)也是$O(lgn)$

顺序统计树完全是根据红黑树进行的改进。每个结点x多出一个size字段，记录以x为根的子树(包括x)的结点数目。具体的算法看算法导论，没什么好重复的。

####区间树
区间树提供$O(lgn)$的插入，删除，查找(查找一个区间是否和区间集合中某个区间重合，如果重合返回区间集合中某个区间，不重合返回空)操作。


区间树也是根据红黑树的改进。每个结点x.key = 区间左端点值。增加了一个属性x.max，表示以x为根的子树中所有区间端点的最大值。


#####Josephus排列

定义Josephus问题：假设n个人围成一个圈，给定一个正整数m，且m<=n。从某个指定的人开始，沿环遇到的每第m个人被移出队伍。每个人移出队伍之后，继续沿环数剩下来的人。这个过程直到所有的n个人都被移出队伍后结束。每个人移出的次序定义了一个来自整数1, 2, ..., n的(n, m)-Josephus排列。例如(m,n)=(7,3)-Josephus排列为<3,6,2,7,5,1,4>

a.假设m是常数，描述一个$O(n)$的算法，能够输出(n, m)-Josephus排列？
建立一个循环单链表，每个结点代表一个元素。然后模拟上面的过程数的过程和出队的过程。时间复杂度应该是$O(m*n)$

b.假设m不是常数，藐视一个$O(nlgn)$的算法，能够输出(n, m)-Josephus排列？
可以使用顺序统计树。假设还有k个元素没移出队伍，k<=n， 现在将要移动的是第j个元素，k减小1表示将j号元素移出，然后下一个需要移出的元素是(j+m-1)小的元素，但是防止越界还需要对这个下标mod k。看伪代码描述

```
JOSEPHUS(n, m)
	initialize T be empty
	for j = 1 to n
		create node x with key = j
		OS-INSERT(T, x)

	j = 1
	for k = n to 1
		j = (j + m - 2) mod k + 1 //因为下次迭代这个j位置人已经被删除了
		x = OS-SELECT(T, j)
		print x.key
		OS-DELETE(T, x)
```


**这个问题还有一个小扩展那就是不需要求出整个序列，只需要求出最后一个剩下的元素是谁？**

这样这个问题就能在$O(n)$的时间复杂度内解决。可以看[求自然语言解释：约瑟夫环之递归算法](https://www.zhihu.com/question/20065611)

解决这个问题的就是利用相邻的两轮之间的编号的关系。现在假设x(k)表示最后剩下来的那个人在剩余k人时在这k人中的编号。目标就变为求x(n)的值。很明显，x(1) = 1--剩余1人时，最后剩余的人的编号肯定是1。那么我们需要找到一个从x(k-1)求解x(k)的递推式。

```
剩余k人时，当前出队的人的编号pos = (m - 1) mod k + 1，那么剩下的人需要重新编号，作为下一轮的每个人的编号。

左边是剩余k人时，每个人的编号。右边是剩余k-1人时每个人的编号

pos + 1  =>  1
pos + 2  =>  2
...
k        =>  k - pos
1        =>  k - pos + 1
...
pos - 2  => k - 2
pos - 1  => k - 1

所以根据上面的对应关系，不难写出递推公式
x(k) = (x(k-1) - 1 + pos + 1 - 1) mod k + 1   化简为x(k) = (x(k-1) + m - 1) mod k + 1
解释一下个公式的组成：x(k-1)-1计算右边相对1位置的偏移，然后pos+1用于加上这个偏移，计算得出左侧的编号，但是因为左侧编号最大为k，因此需要mod k，但是mod k又有新的问题，左侧编号为k的人计算之后编号为0，因此需要稍微修改一下，采取mod k里面减去1，外面加1的方法。
```

代码就不用写了，几行代码就搞定了，关键是分析的思路和方法。
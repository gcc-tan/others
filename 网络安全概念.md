
名词 | 含义
-----|-----
X.509 | X.509是常见通用的证书格式。所有的证书都符合为Public Key Infrastructure (PKI) 制定的 ITU-T X509 国际标准
pkcs1～pkcs12 | 公钥加密（非对称加密）的一种标准(Public Key Cryptography Standards)。一般存储为*pN。
*.der | 证书的二进制存储格式。证书的两种编码之一，但是这种编码不常用
*.pem | 证书或者密钥的Base64文本编码,可以单独存放证书或密钥，也可同时存放证书或者密钥
*.key | 单独存放的pem格式的密钥
*.cer *.crt | 两个指的都是证书，Linux下叫做crt，Windows叫cer。存储格式可以是pem和der
*.crs | 证书签名请求（Certificate signing request），包含证书持有人的信息，如：国家，邮件，域名等信息，最核心的信息还是包含请求者的公钥
*.pfx | 微软的IIS实现
*.jks | Java的keytool实现的证书格式

可以使用openssl在各种不同的证书格式之间进行转换


内容来自：

[SSL中，公钥、私钥、证书的后缀名都是些啥？](https://www.zhihu.com/question/29620953)

[那些证书相关的玩意儿(SSL,X.509,PEM,DER,CRT,CER,KEY,CSR,P12等)](https://www.cnblogs.com/guogangj/p/4118605.html)


###TLS和SSL

之前（可能是刚上大学那会）上网使用HTTP协议的网站很多，但是现在大部分网站使用的都是HTTPS协议了。升级的原因就是为了安全。因此了解TLS和SSL很有必要。其实SSL和TLS使用的技术和知识其实在这本《密码编码学和网络安全——原理与实践——第五版》里面都有详细介绍，这本书个人认为是网络安全知识的一本很好的扫盲书籍。还有就是推荐阮一封的博客，博客里面将这个协议解释得很清楚。废话不多说，先看看什么是SSL和TLS吧。

SSL的版本有1.0，2.0，3.0。然后TLS有1.0，1.1，1.2。然后TLS协议是建立在SSL3.0基础上制定的，TLS 1.0和SSL 3.0的差异很小，但是他们的差异也足以导致两者之间不能互相操作（主要体现在支持的加密算法上不同）。现在使用广泛的就是TLS。有兴趣可以查看[传输层安全协议](https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A)。


先介绍一下SSL协议的作用：

不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险：

1. 窃听风险（eavesdropping）：第三方可以获知通信内容。
2. 篡改风险（tampering）：第三方可以修改通信内容。
3. 冒充风险（pretending）：第三方可以冒充他人身份参与通信。


SSL/TLS协议是为了解决这三大风险而设计的，希望达到：

1. 所有信息都是加密传播，第三方无法窃听。
2. 具有校验机制，一旦被篡改，通信双方会立刻发现。
3. 配备身份证书，防止身份被冒充。

在传统的五层计算机网络中，SSL协议位于传输层和应用层之间。对于应用层协议来说，它是透明的，只是作为一种安全传输的保障存在。SSL协议主要分为两个阶段：第一个阶段的握手过程，这个过程主要是客户端和服务器进行连接，交换一些参数。第二个阶段就是安全传输的阶段，使用的是前面握手过程中产生的对称密钥和对称加密算法对传输内容进行加密。

####SSL协议的握手过程

下面Alice和Bob的对话很形象地说明了SSL传输的整个过程。

![](img/Alice_Bob_ssl_handshake.png)

上图使用文字解释就是下面五个步骤：

第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。
第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。
第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。
第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。
第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。


下面有几个关键点：

1. 第三步确认证书有效。这个过程中主要做以下检查：是否是信任CA颁发的（需要用CA的公钥解密证书中CA私钥签名的消息摘要，利用消息摘要算法，计算hash值，保证证书没有被篡改），检查证书中的域名与实际域名是否一致，证书是否过期。
2. 第五步中使用三个随机数生成session key。这个过程中因为前两个随机数都是明文传输的，所以整个通信的安全取决与第三个随机数，虽然理论上只要保证服务器的公钥长度够长（2048），那么就可以保证session key不被破解。但是为了足够安全，可以把握手阶段的默认算法RSA改成Diffie-Hellman算法。采用DH算法后，premaster secret不需要传递，双方只要交换各自的参数就可以算出这个随机数。具体算法可以参考前面介绍的书籍。

**关于证书和CA的一些问题**

证书：证书里面一般包含公钥，签发机构，签发者签名的消息摘要等一些其他信息。具体的例子可以看我的mosquitto一文中使用的openssl工具。

那么问题就来了，我们知道RSA密码是分成公钥和私钥对的。而CA的签名是使用私钥签名，这样验证证书的有效性就可以使用CA的公钥解密验证。这个过程相当于有两对公钥私钥。一对作为CA使用，一对作为服务器证书使用。而可不可以只用一对公钥私钥，用这个私钥签名对应公钥的证书？

答案是肯定的。这样的证书叫做自签发证书，只需要客户端信任服务器的证书，那么可以在SSL传输过程中正常使用。但是这种方式也有一定的安全问题，具体可以参考[Self-signed certificate](https://en.wikipedia.org/wiki/Self-signed_certificate)


**内容来自**

[SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)

[图解SSL/TLS协议](http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html)




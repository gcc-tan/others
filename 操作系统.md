###什么是死锁？如何避免死锁？
**多个进程竞争一定数量的资源，某个进程申请的资源不可用而进入等待状态。该等待进程有可能再也无法改变其状态**

死锁形成的4个必要条件：
1. 互斥。至少有一个资源处于非共享模式，如果一个进程申请该资源，必须等到该资源被释放为止。
2. 占有并等待。一个资源必须占有至少一个资源，并等待另外一个资源。
3. 非抢占。资源不能被抢占，只能在进程完成任务之后自动释放。
4. 循环等待。有一组等待进程{p0,p1,...,pn}。p0申请的资源被p1占有，p1申请的资源被p2占有,...pn申请的资源被p0占有

这四个条件并不是完全独立的，例如循环等待意味着占有并等待

面对死锁有三种处理的方法：
+ **使用协议预防或者避免死锁**，确保系统不会进入死锁状态
+ 可以允许系统进入死锁状态，然后检测它，并加以恢复
+ 忽视这个问题，认为死锁不会在系统内发生（这个是大多数操作系统采用的策略）

**死锁预防（deadlock prevention）**

死锁预防是一组方法，确保至少一个必要条件不成立。这些方法通过限制资源的申请方式来预防死锁。

+ 互斥。通常不能通过否定互斥这个必要条件来预防死锁。因为很多资源本来就是非共享的。
+ 占有并等待。在进程申请资源时保证进程没有占用任何资源（可以通过一次申请全部资源。或者是：申请一部分，释放该部分，再次申请的方式，）。这样的方式带来的问题是：第一，资源使用效率低。第二，可能发生饥饿（一个进程要使用多个常用资源，可能要永久等待）
+ 非抢占。为了确保这个条件不成立，可以采用如果一个进程占有并申请另外一个不能立即得到的资源，那么其现在分配的资源都可抢占（这个相当于隐式释放）。
+ 循环等待。为了确保这个条件不成立，可对所有资源进程排序，只能按照递增的顺序申请资源。例如，有磁带，磁盘，打印机三个资源，分别对应的值是1, 5, 12。那么如果进程占有了5,只能申请12。

**死锁避免（deadlock avoidence）**

要求操作系统获得进程申请资源和使用资源的额外信息，利用这些信息确定一个资源的申请进程是否应该等待。常见的死锁避免的算法就是银行家算法。


###PCB中包含的内容？

进程控制块（process control block，PCB）。PCB包含一个特定进程的相关信息。

+ 进程状态：状态可包括新的，就绪，运行，等待，停止等。
+ 程序计数器：计数器表示进程要执行的下个指令的地址。
+ CPU寄存器：计算机体系结构不同，寄存器的数量和类型不同。包括累加器，索引寄存器，堆栈指针，通用寄存器和其他条件码信息寄存器。
+ CPU调度信息：包括进程优先级，调度队列的指针和其他调度参数。
+ 内存管理信息：基址和界限寄存器的值，页表，段表
+ 记账信息：CPU时间，实际使用时间，时间界限，记账数据，作业数量等。
+ I/O状态信息：I/O设备列表，打开文件列表









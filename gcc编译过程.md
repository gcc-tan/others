## gcc编译
### gcc编译器处理的四个流程包括 ∶

+ 预处理(也称预编译，Preprocessing)
+ 编译(Compilation)
+ 汇编(Assembly)
+ 链接(Linking)

详细过程是

1. 预处理，首先调用cpp进行预处理，在预处理过程中，对源代码文件中的文件包含(include)、预编译语句(如宏定义define等)进行分析 生成.i文件。

2. 编译，将预处理产生的.i文件进行语法检查，有语法错误报出语法错误。没有语法错误时会编译成汇编语言,产生.s文件
3. 汇编， .s文件还是不能被机器识别和运行，这时候就会把.s文件转换成机器能够识别的二进制文件----生成.o文件
4.  当所有的目标文件都生成之后，gcc就调用ld来完成最后的关键性工作，这个阶段就是链接。在连接阶段，所有的目标文件被安排在可执行程序中的恰当的位置，同时，该程序所调用到的库函数也从各自所在的档案库中连到合适的地方。
c和c++中的库根据链接的不同时间分为两种不同的库
### 常用的gcc选项
> -E 只激活预处理 不产生文件 不过可以重定向或者用-o选项
>> gcc -E hello.c -o hello.i

>-S  只激预处理和编译，就是指把文件编译成为汇编代码 
>> gcc -S hello.c 生成hello.s
>> gcc -S hello.i 将预处理重定向产生的.i文件编译成汇编文件 

> -c   只进行预处理,编译,和汇编,生成成obj文件
>> gcc -c hello.c 可以生成hello.o的二进制文件
>> gcc -c hello.s 将编译产生的.s生成.o的二进制文件

>-o [filename]  生成目标文件的名字
>-L [directory]   指定搜索库文件的目录
>-l [libname]  指定库文件的名字 要去掉前面的lib和后面的.a 或者.so后缀
>-g 生成调试信息，方便gdb调试使用
>-I 指定头文件的搜索目录

### 链接种类

+ **静态链接** 在这种链接方式下，函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码
+ **动态链接** 在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码

两者的主要区别就是动态链接的程序小能够节省内存空间，比较灵活能够比较方便的升级，而静态链接的好处是性能上可能带来优势

在Linux环境下，动态库一般是.so结尾，静态库一般是.a结尾
eg:
现有三个文件
hello.c

	#include"hello.h"
	#include<stdio.h>
	void print()
	{
		printf("hello world\n");
	}

hello.h

	void print();

main.c

	#include"hello.h"
	int main(int argc,char **argv)
	{
		print();
	}

gcc编译动态库

	gcc -fPIC -shared hello.c -o libhello.so //其中-fPIC选项的作用是：表示编译为位置独立的代码 -shared选项指定了是动态链接库
	gcc main.c -lhello -L .                  //-L 指定搜索目录查找库文件 -l链接指定的库文件名 要去掉lib和后缀.so

gcc静态链接库

	gcc -c hello.c
	ar -r libhello.a hello.o // 程序ar配合参数 -r 创建一个新库libhello.a并将命令行中列出的对象文件插入
	gcc -static main.c -L . -lhello


ldd命令 是用来打印目标程序（由命令行参数指定）所链接的所有动态库的信息的

[主要参考](http://www.2cto.com/kf/201610/559123.html) 

	
	
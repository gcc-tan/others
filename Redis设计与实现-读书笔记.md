### 总的感受
因为redis是比较火的nosql数据库，之前在公司实习的时候也用到过。所以就想买本书来学习一下。这本书我花了一个星期的时间，看完了前三章，看的速度还算快，所以有一些感觉不重要的东西就没有细看，只是粗略地看了一眼。看完之后给我的感受是有一定的收获，这本书讲解的地方还是可以，图画得挺好（特别是数据结构的图很赞），中间结合了一定的代码，章节划分也很恰当，能够直接按照感兴趣的章节阅读。但是也有感觉写得不好的地方，就是详略不太得当，redis采用的很多策略是一两句话完全能够解释清楚的，没必要又画图又伪代码又举例子的。


### 数据结构

redis是用c语言实现的，标准的c是没有这些常用的数据结构的。所以redis自己实现了一些常用的数据结构，这些数据结构在整个redis中都用到了，而不仅仅是存储用户传输的数据。下面我就挑选一些比较典型的。

#### 动态字符串（Simple dynamic string）

动态字符串就是为了能够方便修改字符串而定义的一个结构体，结构体的定义如下。这样定义的好处就是能够使用预分配(在字符串长度增加的时候分配的空间多于长度增加的长度，预留出一部分空间，如果下次增加的长度小于这部分空间就可以加速这种写操作)和惰性空间释放(在字符串长度减小时不立即回收缩短的字符串)两种策略，加速字符串的写操作。

```
struct sdshdr
{
	int len;//长度
	int free;//buf的剩余字节
	char buf[];//存储字符串
};
```

#### 字典

字典又称作符号表（symbol table）、关联数组（associative array）或者映射，是一种用于保存键值对（key-value pair）的抽象数据结构。redis采用的是MurmurHash2算法来计算键的hash值，该算法计算速度快，即使输入是规律的，算法也能给出一个很好的随机分布的特性。当Hash键有冲突时采用的是链地址法（separate chaining）解决键冲突。下面给出redis里面定义的字典。

```
//字典
typedef struct dict
{
	dictType *type;//类型特定的函数
	void *privdata;//私有数据

	dictht ht[2];//hash表
	int trehashidx;//rehash索引，该操作不在进行时为-1
}dict;

typedef struct dictType
{
	//计算hash值函数
	unsigned int (*hashFunction)(const void *key);
	//对比键函数
	int (*keyCompare)(void *privdata,const void *key1,const void *key2);
	//复制键函数
	void *(*keyDup)(void *privdata,const void *key);
	//复制值函数
	void *(*valDup)(void *privdata,const void *obj);
}dicType;
//hash表
typedef struct dictht
{
	dictEntry **table;
	unsigned long size;
	unsigned long sizemask;

	unsigned long used;
}dictht;
//hash表节点
typedef struct dictEntry
{
	void *key;//键

	union
	{
		void *val;
		uint64_t u64;
		int64_t s64;
	}v;//值

	struct dictEntry *next;//指向下一个hash表节点
}dictEntry;
```


上面的定义非常经典，有很多值得学习的地方：

+ 利用函数指针，给字典定义了维护字典结构体必要的函数。这里使得面向过程的c语言有一部分面向对象的特性。
+ 为了维护字典的高效查找的效率或者减少内存的使用情况。hash表会根据服务器的运行情况（有没有执行BGSAVE或者BGREWRITEAOF命令）和hash表的负载因子(load_factor = ht[0].used / ht[0].size)进行收缩扩张。因此我们在字典的定义中可以看见，dictht ht[2]定义了两张表，在一般的情况下只会使用ht[0]，在进行hash表的扩张或者收缩(rehash)的时候才会用到ht[1]。由于hash表中的数据量可能很大，为了避免rehash对服务器的性能造成影响，服务器并不是一次性地将ht[0]里面的所有数据迁移到ht[1]里面，采用了一种渐进式rehash的策略——道理也很简单，就是每次对字典进行添加、删除、查找或者更新操作时，除了进行指定的操作外，还会将ht[0]里面的键值对rehash到ht[1]。就这样采用均摊的方式，避免集中式rehash带来的庞大计算量。

#### 跳跃表(skip list)

跳跃表不再细说，是一种平衡树的替代方案，之前写过一片文章就是关于跳跃表的（就是因为看到这里不知道跳跃表这个数据结构）。这个数据结构的思想真的很有意思，实现也较为简单，也能够达到较好的性能。



#### 压缩列表（ziplist）

压缩列表是一系列特殊编码的连续内存块组成的顺序型数据（sequential）结构。压缩列表有由长度（zlbytes），尾部偏移（zltail），节点个数（zllen），节点（entry，存储数据的），结尾标志（zlend）组成。由于节点部分不是固定的长度，故每个节点中还有上一个节点长度的字段。**然后书上说压缩列表是为了节省内存开发的，但是从上面的这个列表的结构来看，好像没有达到节省内存的目的。而且书上说压缩列表使用在实现长度较小的列表键，既然长度小，那么需要存储的数据量肯定不多，使用这个结构去压缩字节有这个必要吗？**


### 对象

这是我认为redis设计比较巧妙的地方之一。redis并没有直接使用上面说的数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含了字符串对象、列表对象、hash对象、集合对象和有序集合对象，每种对象都使用了一种或者多种数据结构。使用这个对象进行包装有很多作用：

+ 针对不同的使用场景选取不同的数据结构实现，优化对象在不同场景下的使用效率。
+ redis建立了基于引用计数的内存回收机制和对象共享机制
+ redis对象带有访问时间的记录信息，方便删除长时间没有使用的对象


### 持久化
作为一个数据库，如果数据都放到内存中，那么断电之后内存中的数据会全部消失。所以需要数据的持久化。redis有两种持久化的方法。一种是rdb文件，一种是aof（append only file）文件。

+ rdb文件就是一种经过压缩的二进制文件，redis将数据库中的键值对都写入这个文件中，通过读取rdb文件可以还原数据库的状态。

+ aof文件就比较有意思了，它是通过保存redis服务器执行的写命令来记录数据库的状态的（在需要还原数据库状态的时候使用一个伪客户端执行aof文件中的命令就行）。但是这个过程有一个问题。**写操作包括增加，删除，修改。假如操作的序列是先增加，然后修改，最后删除。执行这三条命令之后数据库的状态和之前的状态是一模一样的**。而aof文件是采用追加的方式，这三条命令在aof文件中是肯定存在的。这样以来，随着redis服务器的运行，aof文件会越来越大，在还原数据库状态的时候执行aof文件中的命令消耗的时间就很长。为了解决上面的问题，redis提出了一种**aof重写**的机制。这个功能是通过读取当前数据库的状态实现的。举个例子：加入当前数据库中只有一个键值对。`key = list, value = A,B,C,D,E,F`。那么redis通过读取list键对应的值，产生一条`RPUSH "A" "B" "C" "D" "E" "F"`命令，将这条命令写入新的aof文件中，使用新的文件替换之前的aof文件，aof文件重写的工作就完成了。


### 事件

看完书上事件这一章总感觉讲的不是很清楚（可能水平有限）。有几个问题在这里记录一下：

1. 书上说redis是一个事件驱动程序，主要有两类事件，一个是文件事件，一个是时间事件。那么为什么需要使用事件驱动呢？还有对文件事件和时间事件是怎么抽象的？

2. redis的运行方式是单线程的，所以在网络模型这块采用的是I/O多路复用。在选择复用函数的时候明显有一个优先级：`evport > epoll > kqueue > select`？我很好奇为什么会有这样的优先级？


### 复制

redis采用master和slave的方式实现读写分离。master负责写请求，slave是master数据的复制，负责读请求。通过这种方式增加数据库的并行度。

redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：

+ 同步是让主从服务器状态一致
+ 命令传播用于刚进行同步操作的主从服务器，状态不一致时（可能刚进行完同步操作，主服务器就执行了客户端的写命令）重新回到一致的状态

**同步**

整个从服务器向主服务器同步的过程是通过向主服务器发送SYNC命令完成的，以下是SYNC的执行过程：

1. 从服务器向主服务器发送SYNC命令
2. 收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个rdb文件，并使用一个缓冲区记录从现在开始的所有写命令。
3. 当BGSAVE命令执行完毕时，主服务器将这个rdb文件发送给从服务器，从服务器接收并载入这个rdb文件，更新自己的数据库状态到主服务器执行BGSAVE命令行时的状态。
4. 主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些命令，更新自己的数据库状态到



**命令传播**

这个很简单，就是主服务器向从服务器发送造成状态不一致的命令，让从服务器执行，重新回到一致的状态。

为了提高在断线的情况下操作低效的问题（旧版的在断线之后采取重新发送SYNC命令，进行完整重同步），新版的复制增加了一个部分重同步操作（执行丢失的命令）解决这个问题。而新版的部分重同步增加了一个复制偏移量，复制积压缓冲区。复制偏移量是主从服务器分别维护的，每次主服务器向从服务器传播N字节数据（应该是写命令）时，复制偏移就增加N，如果从服务器接受到N字节数据，它的复制偏移量也增加N。复制积压缓冲区是主服务器维护的一个先进先出的队列。主服务器进行命令传播时会将命令写入复制积压缓冲区。当从服务器掉线重新连上主服务器时，主服务器根据从服务器的复制偏移量是否在复制积压缓冲区中，如果不在执行完整重同步，如果在执行部分重同步。





### Sentinel

这是一个特殊的redis服务器，和普通的redis服务器有区别。它是用来监视redis集群的运行状况的，通过投票的方式判断服务器是否下线，然后使用一个叫Raft算法选举领头的sentinel，由领头的sentinel负责下线服务器的故障转移。



### 集群

一个Redis的集群是由很多的节点组成的。如果一个节点A想要加入一个集群。那么选择集群中的一个节点B。A与B进行“握手”，然后B会把节点A的信息通过Gossip协议传递给集群中的其他节点。（整个命令的过程就是`CLUSTER MEET [ip] [port]`完成）



Redis的集群通过分片的方式保存数据库中的键值对，集群中的整个数据库被分为16384个槽（slot），数据库中的每个键都属于16384个槽中的一个，集群中的每个节点可以处理0个或者是至多16384个槽。




以上就是这一个星期的成果了，说来惭愧。。。感觉总结起来并没有什么东西。





















之前没有读过内核相关的内容，这是读的第一本书，困难不少。这里只是个人对书中内容的理解。



###进程调度
Linux系统中进程的状态：
+ R(running)。可执行状态，包括正在执行和等待执行的进程
+ S（sleeping）。可中断的睡眠状态。这里的中断应该是被信号中断
+ D（disk sleep）。不可中断睡眠状态
+ T（stopped）。接收SIGSTOP信号，进程进入T状态
+ t（tracing stop）。
+ X（dead）。退出状态即将被销毁
+ Z（zombie）。退出状态成为僵尸进程

![](img/status_transform.svg)

####nice值，优先级，实时进程
对nice值大家肯定有所耳闻。在Linux系统中nice值的取值范围是从-20～19。一个40个等级，如果nice值大，说明这个进程越nice，这就间接说明容易被欺负，因此优先级就低。nice值一经确定就不会改变（除非使用相关的系统调用或者命令），因此nice值又称为**静态优先级**。例如nice命令可以以某个nice值运行进程，renice命令可以对已经运行的进程的nice值进程调整。

而调度算法里面使用的优先级是**动态优先级**。那一个进程的nice值怎么转换成动态优先级能？其实就是一个简单的映射。将-20~19的范围映射到MAX_RT_PRIO～MAX_RT_PRIO + 40。MAX_RT_PRIO的默认值是100。所以就是100~139的范围。（Linux的chrt命令能够指定和改变这个优先级）

那么我们可能会有疑问了，那剩下来的0～99的优先级是干嘛的呢？

为了解决这个问题先介绍实时操作系统，实时操作系统要求保证实时进程能够在较短的时间内响应，并且要求最小的中断延时和进程切换延时。

为了在一定程度上支持实时的特性，Linux系统将进程分成两类：

+ 实时进程
+ 非实时进程

上面两种进程的区别就是通过优先级区分的。0～99的优先级留给了实时进程。100～139的优先级表示非实时进程。

因为实时进程要求响应时间快。所以系统的整体调度策略是：如果系统中存在实时进程，那么优先调度实时进程，直到实时进程退出或者主动让出CPU，才会调度非实时进程。

对于实时进程可以用的调度策略是：SCHED_FIFO、SCHED_RR，而对于非实时进程则是：SCHED_OTHER、SCHED_BATCH、SCHED_IDLE。

>注意实时进程的调度策略是针对实时进程的优先级相同时才起作用。例如两个优先级相同的实时进程A，B如果采用FIFO策略，那么先执行的实时进程A让出CPU时B才能执行。而如果A的优先级小于B，且A正在执行。这个时候B需要执行，那么A就会被抢占，直到B执行完成。


####O(1)调度算法

之所以叫O(1)调度算法就是因为这个算法与需要调度执行的进程数量无关。

算法的核心内容就是下面几行代码：

```
#define MAX_USER_RT_PRIO        100
#define MAX_RT_PRIO             MAX_USER_RT_PRIO
#define MAX_PRIO                (MAX_RT_PRIO + 40)//140
typedef struct prio_array prio_array_t;
struct prio_array {
        unsigned int nr_active;
        unsigned long bitmap[BITMAP_SIZE];//如果long为4个字节，BITMAP_SIZE为5。用1bit表示某个优先级是否有进程，1表示存在，0表示不存在
        struct list_head queue[MAX_PRIO];//queue[prio]表示优先级都为prio的进程的链表
};
```

首先内核为每个CPU核心维护有且只有一个就绪队列（就是R状态的进程）。这个就绪队列中包含很多信息，最重要的就是两个`prio_array_t *active`和`prio_array_t *expired`。都是上面的结构体类型。active表示的是当前运行周期内时间片还没有用完的进程（活动进程集合），expired是时间片已经用完的进程（过期进程集合）。

该调度算法的执行过程还是从可运行的进程中选取优先级最大的，执行。选取优先级最大的通过查找active的bitmap中找到第一个为1的bit位，计算该比特位对应的优先级，然后在queue中查找该优先级的进程链表，然后选取一个进程调度执行。执行完成之后将该进程移入expired中，同时更新该进程的执行时间片和优先级等信息。

如果活动进程集合为空，那么所有进程调度完成。交换活动进程集合和过期进程集合。重复上面过程。


####CFS调度算法
这块内容中，比较难理解的就是CFS算法。

其实算法的思想比较简单，就是按照不同的权重比分配不同的运行时间。在CFS中，会设定一个目标延迟。目标延迟就是调度周期，越小的调度周期将带来越好的交互性，同时也更接近于完美的多任务。

>例如目标延迟为20ms，这时有2个优先级相同的进程。那么每个进程能够运行10ms。这时有4个优先级相同的进程，每个进程只能运行5ms。当运行进程的数量趋于无限时，每个进程获得的运行时间趋近于0。这样会造成不可接受的切换消耗。CFS为此引进了每个进程获得的时间片的底线，这个底线称为最小粒度。默认情况是1ms


在CFS的实现中vruntime很让人难以理解。因为在CFS调度使用红黑树存储了系统中可运行进程，其key值就是vruntime。每次都是挑选红黑树中最左侧（也就是vruntime最小的节点进行调度）。

在一个调度周期中：

a) **进程实际运行时间 = 调度周期 * 进程权重 / 可运行进程权重之和 **

每个进程的vruntime的更新公式（NICE_0_LOAD表示的是nice值为0的进程的权重，值为1024）：

b) **vruntime += 实际运行时间 * NICE_0_LOAD / 进程权重**

将a)带入b)中计算得**vruntime += 调度周期 * NICE_0_LOAD / 可运行进程权重之和**。因此在一个调度周期中，每个进程的vruntime的增长速度是一样的。这就CFS需要调度vruntime小的进程的原因了。

下面的表是nice值对应的权重

```
//进程的优先级nice值(从-20~19，nice越大优先级其实越低)对应的权重
static const int prio_to_weight[40] = {
 /* -20 */     88761,    71755,     56483,     46273,    36291,
 /* -15 */     29154,    23254,     18705,     14949,    11916,
 /* -10 */      9548,     7620,      6100,      4904,     3906,
 /*  -5 */      3121,     2501,      1991,      1586,     1277,
 /*   0 */      1024,      820,       655,       526,      423,
 /*   5 */       335,      272,       215,       172,      137,
 /*  10 */       110,       87,        70,        56,       45,
 /*  15 */        36,       29,        23,        18,        5,
};
```

内容来自：

[进程状态](https://github.com/tobegit3hub/understand_linux_process/blob/master/process_basic/status.md)

[CFS中的虚拟运行时间vruntime 的理解](https://blog.csdn.net/yuzaipiaofei/article/details/78080054)

[linux内核分析——CFS（完全公平调度算法）](http://blog.51cto.com/muyunzhe/1651853)

[Linux2.6进程调度分析(2)-调度算法](http://edsionte.com/techblog/archives/2851)
## unix信号--apue读书笔记
#### 简介
信号是软中断，很多比较重要的应用程序都需要信号处理。信号提供了一种异步处理事件的方法，例如，终端用户键入中断键，会通过信号机制停止一个程序，或者及早终止管道中的下个程序。
某个信号出现时，可以告诉内核有三种方式进行处理

+ 忽略此信号。大多数信号可以按照这种方式进行处理，但是有两种信号不能被忽视：SIGKILL和SIGSTOP，因为出于安全考虑为了给超级用户提供进程终止和停止的方法
+ 捕捉信号。就是用户自定义一个函数来告诉内核在某种信号发生时候用户希望对这种事情进行处理  
> 捕捉信号的api接口很简单在 <signal.h> 头文件中有signal函数，不过为了语义的一致性最好使用sigaction函数去实现
+ 执行系统默认的动作。大多数信号的系统默认的动作就是终止该进程

#### 信号的分类
+ 可靠信号--也称实时信号 信号排队不丢失
+ 不可靠信号--也称非实时信号 信号不排队丢失
> `kill -l`就能列出系统能够支持的信号，在linux中从1到31都是不可靠信号

> 这里的信号排队我就一个疑问。在unix网络编程的第五章有个有意思的例子。就是服务器在启动的时候就注册了一个信号处理函数去处理子进程退出时候产生的SIGCHLD信号（**如果不处理该信号子进程就会变成僵尸进程消耗系统资源。除掉僵尸进程的方法只有干掉它的父进程让他变成init进程的子进程，init进程就会调用wait方法然后从进程表里面清除它，其他的什么直接kill xxx的都是扯淡 **）服务器的工作方式是采用fork的方式子进程去处理客户端的请求。这时候的客户端程序是这么写的发起5个连接去连接服务器，然后同时退出。这样在服务器端就对应了5个子进程基本同时退出（假设服务器与客户段运行在同一个主机）然后讲道理是应该没有僵尸进程，因为信号处理函数已经有wait处理，但是实验结果不确定，有时候没有，时候有1个，有时候有3个僵尸进程。书上说信号不排队这可以解释一部分问题。但从上面的实验结果来分析说明排队也是有时间长度的，因为每次执行信号处理函数都能干掉一个僵尸进程。有没有剩下僵尸进程的那么信号处理函数就被执行的五次，信号没有出现排队丢失的现象。而什么时间进行排队apue上好像没有讲到

#### 中断的系统调用
如果进程在执行一个低速的系统调用期间捕捉到一个信号，则该系统调用就被中断不再执行。该系统调用出错，其errno设置为EINTR。为了支持这种性质，系统调用分为两类。低速系统调用和其他系统调用。详情见apue的第十章

#### 可重入函数
进程捕捉到信号对其进行处理时，进程正在执行正常的指令序列就被信号处理程序临时中断，它首先执行信号处理函数的指令，如果从信号处理函数返回（没有调用exit或者longjmp），则继续执行在捕捉信号时进程正在执行的正常指令序列。但是如果进程在执行malloc，在其堆中分配空间。然后不巧的是在信号处理函数中也调用了malloc，这会对进程造成极大的破坏。因为malloc通常会为它分配的存储区维护一个链表。插入执行信号处理程序时，malloc可能正在更新链表。
所以Single UNIX Specification说明了保证在信号处理程序中保证调用安全的函数，也被称为异步信号安全的函数。除了可重入外，它会阻塞任何引起不一致的信号的发送

